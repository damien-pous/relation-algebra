(*******************************************************************)
(*  This is part of RelationAlgebra, it is distributed under the   *)
(*    terms of the GNU Lesser General Public License version 3     *)
(*              (see file LICENSE for more details)                *)
(*                                                                 *)
(*  Copyright 2012: Damien Pous. (CNRS, LIP - ENS Lyon, UMR 5668)  *)
(*******************************************************************)

(** * rewriting: additional rewriting support *)

Require Import monoid.


(** * rewriting modulo associativity of [dot] *)

(** We notice that to rewrite modulo A, it suffices to normalise
    associativity, and to use an extended lemma: for instance, if one
    wants to rewrite using a closed hypothesis 

    [H: a_1*...*a_n == c]

    in a goal including a subterm like [d*e*a_1*...*a_n*f], then one
    can simply rewrite using 

    [(ext_weq_n H): forall x, x*a_1*...*a_n == x*c] 

    where ext_weq_n is the appropriate lemma (see rewriting.v).
    
    Such a lemma could be generated by hand, but it's a bit heavy, so
    that we simply hardwire it for n=2,3,4

    This trick generalises to "open" equations, like

    [H: forall x y, P x y -> forall z, y*(x+z)*y == y]

    where one wants to rewrite using 
    [(fun x y Hxy z => ext_weq_3 (H x y Hxy z))]
    
    The ML plugin [mrewrite] generates such abstractions in the
    appropriate way, taking care efficiently of the order in which one
    wants to rewrite, and whether we have an equation or an
    inequation. (Doing so in Ltac is both painful and inefficient.)

    Of course the method is incomplete (e.g., if [y] has to be
    instantiated by a product), but it seems enough for most common
    situations.  The advantage over using the AAC_tactics library is
    that it's much faster since reification is "syntactic", and that
    it works for typed structures and heterogeneous terms, which are
    not supported in AAC_tactics. 
*)

Lemma ext_leq_2 `{laws} {n m p} (x: X n m) (y: X m p) v: x*y <== v -> 
  forall o (u: X o n), u*x*y <== u*v. 
Proof. intros E ? ?. now rewrite <-E, !dotA. Qed.

Lemma ext_leq_3 `{laws} {n m p q} (x: X n m) (y: X m p) (z: X p q) v: x*y*z <== v -> 
  forall o (u: X o n), u*x*y*z <== u*v. 
Proof. intros E ? ?. now rewrite <-E, !dotA. Qed. 

Lemma ext_leq_4 `{laws} {n m p q r} (x: X n m) (y: X m p) (z: X p q) (t: X q r) v: x*y*z*t <== v -> 
  forall o (u: X o n), u*x*y*z*t <== u*v. 
Proof. intros E ? ?. now rewrite <-E, !dotA. Qed. 


Lemma ext_weq_2 `{laws} {n m p} (x: X n m) (y: X m p) v: x*y == v -> 
  forall o (u: X o n), u*x*y == u*v. 
Proof. intros E ? ?. now rewrite <-E, !dotA. Qed.

Lemma ext_weq_3 `{laws} {n m p q} (x: X n m) (y: X m p) (z: X p q) v: x*y*z == v -> 
  forall o (u: X o n), u*x*y*z == u*v. 
Proof. intros E ? ?. now rewrite <-E, !dotA. Qed. 

Lemma ext_weq_4 `{laws} {n m p q r} (x: X n m) (y: X m p) (z: X p q) (t: X q r) v: x*y*z*t == v -> 
  forall o (u: X o n), u*x*y*z*t == u*v. 
Proof. intros E ? ?. now rewrite <-E, !dotA. Qed. 


Lemma ext_leq_2' `{laws} {n m p} (x: X n m) (y: X m p) v: v <== x*y -> 
  forall o (u: X o n), u*v <== u*x*y. 
Proof. intros E ? ?. now rewrite E, !dotA. Qed.

Lemma ext_leq_3' `{laws} {n m p q} (x: X n m) (y: X m p) (z: X p q) v: v <== x*y*z -> 
  forall o (u: X o n), u*v <== u*x*y*z. 
Proof. intros E ? ?. now rewrite E, !dotA. Qed. 

Lemma ext_leq_4' `{laws} {n m p q r} (x: X n m) (y: X m p) (z: X p q) (t: X q r) v: v <== x*y*z*t -> 
  forall o (u: X o n), u*v <== u*x*y*z*t. 
Proof. intros E ? ?. now rewrite E, !dotA. Qed. 


Lemma ext_weq_2' `{laws} {n m p} (x: X n m) (y: X m p) v: v == x*y -> 
  forall o (u: X o n), u*v == u*x*y. 
Proof. intros E ? ?. now rewrite E, !dotA. Qed.

Lemma ext_weq_3' `{laws} {n m p q} (x: X n m) (y: X m p) (z: X p q) v: v == x*y*z -> 
  forall o (u: X o n), u*v == u*x*y*z. 
Proof. intros E ? ?. now rewrite E, !dotA. Qed. 

Lemma ext_weq_4' `{laws} {n m p q r} (x: X n m) (y: X m p) (z: X p q) (t: X q r) v: v == x*y*z*t -> 
  forall o (u: X o n), u*v == u*x*y*z*t. 
Proof. intros E ? ?. now rewrite E, !dotA. Qed. 


Declare ML Module "mrewrite".

(** User-end rewriting tactics *)

Tactic Notation "mrewrite" constr(H) :=
  rewrite ?dotA; (rewrite H || ra_extend (fun H => rewrite H) ->H); [rewrite ?dotA|..].
Tactic Notation "mrewrite" "<-" constr(H) :=
  rewrite ?dotA; (rewrite <-H || ra_extend (fun H => rewrite <-H) <-H); [rewrite ?dotA|..].
Tactic Notation "mrewrite" constr(H) "in" hyp(H') :=
  rewrite ?dotA in H'; (rewrite H in H' || ra_extend (fun H => rewrite H in H') ->H); rewrite ?dotA in H'.
Tactic Notation "mrewrite" "<-" constr(H) "in" hyp(H') :=
  rewrite ?dotA in H'; (rewrite <-H in H' || ra_extend (fun H => rewrite <-H in H') <-H); rewrite ?dotA in H'.



(** * Bridge with AAC_tactics *)

(** (to be activated manually, by uncommenting the lines below.) *)

(*
Require Export AAC.

Section lattice.
Context `{lattice.laws}. 

Global Instance aac_cupA `{CUP<<l} : Associative weq cup := cupA.
Global Instance aac_cupC `{CUP<<l} : Commutative weq cup := cupC.
Global Instance aac_cupU `{BOT+CUP<<l} : Unit weq cup bot := Build_Unit _ _ _ cupbx cupxb.

Global Instance aac_capA `{CAP<<l} : Associative weq cap := capA.
Global Instance aac_capC `{CAP<<l} : Commutative weq cap := capC.
Global Instance aac_capU `{TOP+CAP<<l} : Unit weq cap top := Build_Unit _ _ _ captx capxt.

Global Instance aac_lift_leq_weq : AAC_lift leq weq. 
Proof. constructor; eauto with typeclass_instances. Qed.

End lattice.

Section monoid.
Context `{monoid.laws} {n: ob X}.
Global Instance aac_dotA: Associative weq (dot n n n) := (@dotA _ _ _ n n n n).
Global Instance aac_dotU: Unit weq (dot n n n) (one n). 
Proof. constructor; intro. apply dot1x. apply dotx1. Qed.
End monoid.
*)

(* tests for AAC_tactics *)
(*
Require Import kleene.
Goal forall `{laws} `{BKA<<l} n (a b c: X n n), a+b == c -> (forall x: X n n, x*x == x) -> 
  a*b+b+1*a+(b+0)^* == a*b*c*b*c*a+0.
Proof. 
  intros. aac_normalise. 
  aac_rewrite H1. 
  aac_rewrite H2 in_right. 
Abort.
Require Import rel.
Goal forall (a b c: rel nat nat), a+b == c -> (forall x: rel nat nat, x*x == x) -> 
  a*b+b+1*a+(b+0)^* == a*b*c*b*c*a+0.
Proof.
  intros.
  aac_rewrite H.
  aac_rewrite H0 in_right.
  aac_normalise. ra_fold rel_monoid_ops.
  (* TOFIX: too much simplifications *)
Abort.
*)
